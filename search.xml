<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Navicat Premium 远程连接 sqlserver</title>
    <url>/2020/05/30/Navicat%20Premium%20%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%20sqlserver/</url>
    <content><![CDATA[<h4 id="Navicat-Premium远程连接-sqlserver"><a href="#Navicat-Premium远程连接-sqlserver" class="headerlink" title="Navicat Premium远程连接 sqlserver"></a>Navicat Premium远程连接 sqlserver</h4><p><strong><em>注意，sqlserver配置的时候，主机名或ip地址这一栏，要讲ip地址和端口号都要填上，并且，中间用逗号隔开，逗号！\</em></strong></p>
<p>配置入下图所示：</p>
<p><img src="http://fp1.fghrsh.net/2020/05/30/52614bce2772f1ad67ffb35e1df994b1.png" alt=""></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sqlserver</tag>
        <tag>navicat</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7设置Tomcat开机自启</title>
    <url>/2020/05/26/CentOS7%E8%AE%BE%E7%BD%AETomcat%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</url>
    <content><![CDATA[<h4 id="安装Java环境"><a href="#安装Java环境" class="headerlink" title="安装Java环境"></a>安装Java环境</h4><h5 id="1、使用-yum-安装-java8"><a href="#1、使用-yum-安装-java8" class="headerlink" title="1、使用 yum 安装 java8"></a>1、使用 <code>yum</code> 安装 <code>java8</code></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum search java | grep jdk</span><br></pre></td></tr></table></figure>

<p><img src="http://fp1.fghrsh.net/2020/05/23/87d41369492de698d8b013864b08ce35.png" alt=""></p>
<p>这里选择安装 <code>java8</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h5 id="2、安装成功后查看-java-安装的位置"><a href="#2、安装成功后查看-java-安装的位置" class="headerlink" title="2、安装成功后查看 java 安装的位置"></a>2、安装成功后查看 <code>java</code> 安装的位置</h5><p>通过 <code>yum</code> 安装的 <code>java</code> 放在固定的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ll /usr/lib/jvm</span><br></pre></td></tr></table></figure>

<p><img src="http://fp1.fghrsh.net/2020/05/23/3a248346c4f87db0c1ff76297b6f46a1.png" alt=""></p>
<h5 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑该文件，在最后加上如下内容:（jdk 版本需要自行填写，上面红框内容复制即可）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> java environment</span></span><br><span class="line">JAVA_HOME=/user/lib/jvm/java-1.8.0-openjdk-1.8.0.252.b09-2.el6_10.x86_64</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置好之后按下 Esc 键退出编辑模式，按下 :wq 保存并退出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出后刷新配置，使其生效</span></span><br><span class="line">source /etc/profeil</span><br></pre></td></tr></table></figure>

<h5 id="4、查看-java-版本"><a href="#4、查看-java-版本" class="headerlink" title="4、查看 java 版本"></a>4、查看 <code>java</code> 版本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p><img src="http://fp1.fghrsh.net/2020/05/23/fbc6c6564a699349d910ec7fc431efdd.png" alt=""></p>
<h4 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h4><h5 id="1、下载tomcat8-5-55"><a href="#1、下载tomcat8-5-55" class="headerlink" title="1、下载tomcat8.5.55"></a>1、下载tomcat8.5.55</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://downloads.apache.org/tomcat/tomcat-8/v8.5.55/bin/apache-tomcat-8.5.55.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="2、解压tomcat到当前目录下"><a href="#2、解压tomcat到当前目录下" class="headerlink" title="2、解压tomcat到当前目录下"></a>2、解压tomcat到当前目录下</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.5.55.tar.gz -C ./</span><br></pre></td></tr></table></figure>

<h5 id="3、启动tomcat"><a href="#3、启动tomcat" class="headerlink" title="3、启动tomcat"></a>3、启动tomcat</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd apache-tomcat-8.5.55</span><br><span class="line">bin/startup.sh</span><br></pre></td></tr></table></figure>

<h5 id="4、测试访问"><a href="#4、测试访问" class="headerlink" title="4、测试访问"></a>4、测试访问</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl localhost:8080</span><br></pre></td></tr></table></figure>

<h4 id="设置-tomcat-开机自启"><a href="#设置-tomcat-开机自启" class="headerlink" title="设置 tomcat 开机自启"></a>设置 <code>tomcat</code> 开机自启</h4><h5 id="1、为-tomcat-添加启动参数"><a href="#1、为-tomcat-添加启动参数" class="headerlink" title="1、为 tomcat 添加启动参数"></a>1、为 <code>tomcat</code> 添加启动参数</h5><p><code>catalina.sh</code> 在执行的时候会调用同级路径下的 <code>setenv.sh</code> 来设置额外的环境变量，因此在 <code>tomcat</code>根目录下的 <code>bin</code> 文件夹下创建 <code>setenv.sh</code> 文件，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置JAVA_HOME</span></span><br><span class="line">export JAVA_HOME=/user/lib/jvm/java-1.8.0-openjdk-1.8.0.252.b09-2.el6_10.x86_64</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">export CATALINA_HOME=/usr/local/tomcat/apache-tomcat-8.5.55</span><br><span class="line">export CATALINA_BASE=/usr/local/tomcat/apache-tomcat-8.5.55</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置Tomcat的PID文件</span></span><br><span class="line">CATALINA_PID="$CATALINA_BASE/tomcat.pid"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加JVM选项</span></span><br><span class="line">JAVA_OPTS="-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m"</span><br></pre></td></tr></table></figure>

<h5 id="2、在-usr-lib-systemd-system-路径下添加-tomcat-service-文件，内容如下"><a href="#2、在-usr-lib-systemd-system-路径下添加-tomcat-service-文件，内容如下" class="headerlink" title="2、在 /usr/lib/systemd/system 路径下添加 tomcat.service 文件，内容如下"></a>2、在 <code>/usr/lib/systemd/system</code> 路径下添加 <code>tomcat.service</code> 文件，内容如下</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Tomcat</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/tomcat/apache-tomcat-8.5.55/tomcat.pid</span><br><span class="line">ExecStart=/usr/local/tomcat/apache-tomcat-8.5.55/bin/catalina.sh start</span><br><span class="line">ExecReload=/usr/local/tomcat/apache-tomcat-8.5.55/bin/catalina.sh restart</span><br><span class="line">ExecStop=/usr/local/tomcat/apache-tomcat-8.5.55/bin/catalina.sh stop</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h5 id="3、把-tomcat-加入开机自动启"><a href="#3、把-tomcat-加入开机自动启" class="headerlink" title="3、把 tomcat 加入开机自动启"></a>3、把 <code>tomcat</code> 加入开机自动启</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable tomcat.service</span><br></pre></td></tr></table></figure>

<h5 id="4、重启服务器"><a href="#4、重启服务器" class="headerlink" title="4、重启服务器"></a>4、重启服务器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h5 id="5、再次连接后，查看服务状态"><a href="#5、再次连接后，查看服务状态" class="headerlink" title="5、再次连接后，查看服务状态"></a>5、再次连接后，查看服务状态</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status tomcat.service</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA安装Activiti插件后中文乱码问题</title>
    <url>/2020/05/30/IDEA%E5%AE%89%E8%A3%85Activiti%E6%8F%92%E4%BB%B6%E5%90%8E%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近项目中使用了 <code>activiti</code> 工作流，需要实现自定义流程，这样就需要通过代码创建流程中的各个节点和流转条件，但是用代码实现后生成到本地的 <code>bpm</code> 文件用 <code>IDEA</code> 中下载的插件 <code>actiBPM</code> 打开之后中文乱码。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>IDEA -&gt; 帮助 -&gt; 编辑自定义 VM 选项 -&gt; 末尾添加一行 <code>-Dfile.encoding=UTF-8</code> -&gt; 重启IDEA即可</p>
<p>（注：IDEA 2020 版本已经有官方的汉化插件了）</p>
<p><img src="http://fp1.fghrsh.net/2020/05/30/d921cb9e4426d686cc100d46ee9f680f.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务手动回滚</title>
    <url>/2020/05/30/Spring%E4%BA%8B%E5%8A%A1%E6%89%8B%E5%8A%A8%E5%9B%9E%E6%BB%9A/</url>
    <content><![CDATA[<p><strong><code>Spring</code> 的事务一般分为声明式事务（或叫注解事务）和编程式事务，编程式事务比较灵活，可以将事务的粒度控制的更细，并且可以控制何时提交，哪种情况回滚。而声明式事务使用 <code>@Transactional</code> 注解，使用起来没有那么灵活，但是对业务代码没有入侵，而且本身支持一些异常情况下的回滚。但是这个异常是不可以捕获的，如果代码里捕获了，那么事务中已经执行了的部分会提交。代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">boolean</span> <span class="title">update</span>()</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 操作 A</span></span><br><span class="line">        <span class="comment">// 操作 B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        log.error(<span class="string">"事务失败"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作 A 成功，B 抛出异常，但是被 <code>catch</code> 捕获并处理，这样异常并没有抛出来，而 <code>Spring</code> 声明式事务是基于 <code>AOP</code> 的，所以也就认为这段操作没有异常，虽然返回的失败，但是 A 操作已经被提交。那么如果想要自己控制异常的时候返回结果，且希望事务回滚要怎么操作呢？其实只要加一段代码就可以，上面的 <code>catch</code> 语句中修改为如下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">log.error(<span class="string">"事务失败"</span>, e);</span><br><span class="line">TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line"><span class="keyword">return</span> Boolean.FALSE;</span><br></pre></td></tr></table></figure>

<p><strong>加上一段代码，就可以将事务回滚。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker打包本地镜像至其他主机上运行</title>
    <url>/2020/05/30/Docker%E6%89%93%E5%8C%85%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E8%87%B3%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E4%B8%8A%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>docker</code> 获取镜像的方式除了 <code>pull</code> 到仓库之外还有一种是将本地镜像打包拷贝给其他宿主主机来运行。假设现实环境中本地仓库和远程仓库连接异常，那么我们将事先打包好的镜像分发给其他 <code>docker</code> 节点用也是一种解决方案。</p>
<h4 id="具体操作步骤如下"><a href="#具体操作步骤如下" class="headerlink" title="具体操作步骤如下"></a>具体操作步骤如下</h4><h5 id="1、执行如下命令找到被打包镜像的名字和版本号（版本号-TAG）"><a href="#1、执行如下命令找到被打包镜像的名字和版本号（版本号-TAG）" class="headerlink" title="1、执行如下命令找到被打包镜像的名字和版本号（版本号 = TAG）"></a>1、执行如下命令找到被打包镜像的名字和版本号（版本号 = TAG）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h5 id="2、docker-打包镜像的两种方式（选一种执行即可）"><a href="#2、docker-打包镜像的两种方式（选一种执行即可）" class="headerlink" title="2、docker 打包镜像的两种方式（选一种执行即可）"></a>2、<code>docker</code> 打包镜像的两种方式（选一种执行即可）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save 镜像名字:版本号 &gt; /root/打包名字.tar</span><br><span class="line">docker save -o /root/打包名字.tar 镜像名字:版本号</span><br></pre></td></tr></table></figure>

<h5 id="3、将打包的镜像上分法到其他宿主机的-root-目录下"><a href="#3、将打包的镜像上分法到其他宿主机的-root-目录下" class="headerlink" title="3、将打包的镜像上分法到其他宿主机的 /root/ 目录下"></a>3、将打包的镜像上分法到其他宿主机的 <code>/root/</code> 目录下</h5><h5 id="4、将打成-tar-报的镜像-load-出来"><a href="#4、将打成-tar-报的镜像-load-出来" class="headerlink" title="4、将打成 tar 报的镜像 load 出来"></a>4、将打成 <code>tar</code> 报的镜像 <code>load</code> 出来</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load &lt; /root/打包名字.tar</span><br></pre></td></tr></table></figure>

<h5 id="5、查看-load-出来的镜像"><a href="#5、查看-load-出来的镜像" class="headerlink" title="5、查看 load 出来的镜像"></a>5、查看 <code>load</code> 出来的镜像</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h5 id="6、如果-load-出来的镜像其名字和版本号均为-none，我们要通过-tag-命令赋予名字和版本号"><a href="#6、如果-load-出来的镜像其名字和版本号均为-none，我们要通过-tag-命令赋予名字和版本号" class="headerlink" title="6、如果 load 出来的镜像其名字和版本号均为 none，我们要通过 tag 命令赋予名字和版本号"></a>6、如果 <code>load</code> 出来的镜像其名字和版本号均为 <code>none</code>，我们要通过 <code>tag</code> 命令赋予名字和版本号</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag 镜像ID 镜像名字:版本号</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows插入安卓设备AndroidStudio无法识别</title>
    <url>/2020/01/14/Windows%E6%8F%92%E5%85%A5%E5%AE%89%E5%8D%93%E8%AE%BE%E5%A4%87AndroidStudio%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>今天在准备使用安卓设备进行真机测试，但是在插入电脑后，提示Adb Inferface驱动无法安装 </p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>实际上Android SDK中带有Adb Interface的驱动，可以安装自带驱动。</p>
<p>其中驱动存放的位置为：SDK安装位置\extras\google\usb_driver\android_winusb.inf</p>
<h5 id="1、计算机–-gt-右击-–-gt-管理-–-gt-设备管理器"><a href="#1、计算机–-gt-右击-–-gt-管理-–-gt-设备管理器" class="headerlink" title="1、计算机–&gt;  右击 –&gt; 管理 –&gt; 设备管理器"></a>1、计算机–&gt;  右击 –&gt; 管理 –&gt; 设备管理器</h5><a id="more"></a>

<h5 id="2、双击带黄色感叹号的ADB-Interface"><a href="#2、双击带黄色感叹号的ADB-Interface" class="headerlink" title="2、双击带黄色感叹号的ADB Interface"></a>2、双击带黄色感叹号的ADB Interface</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/2171c976e2e71020c6c6c655918fac97.png" alt=""></p>
<h5 id="3、点击更新驱动程序"><a href="#3、点击更新驱动程序" class="headerlink" title="3、点击更新驱动程序"></a>3、点击更新驱动程序</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/6803fefeb64a80b43bc2bfe349ad5dbf.png" alt=""></p>
<h5 id="4、点击-“浏览计算机以。。。。。”"><a href="#4、点击-“浏览计算机以。。。。。”" class="headerlink" title="4、点击 “浏览计算机以。。。。。”"></a>4、点击 “浏览计算机以。。。。。”</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/39b7d583e910af5e544e0fea5b996a63.png" alt=""></p>
<h5 id="5、点击“从计算机的设备。。。”"><a href="#5、点击“从计算机的设备。。。”" class="headerlink" title="5、点击“从计算机的设备。。。”"></a>5、点击“从计算机的设备。。。”</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/9b298b42c7ab3b299778228a7c9f4f46.png" alt=""></p>
<h5 id="6、选中显示所有设备点击下一步"><a href="#6、选中显示所有设备点击下一步" class="headerlink" title="6、选中显示所有设备点击下一步"></a>6、选中显示所有设备点击下一步</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/93afd86b281125e29a061dd354bc0206.png" alt=""></p>
<h5 id="7、点击“从磁盘安装”"><a href="#7、点击“从磁盘安装”" class="headerlink" title="7、点击“从磁盘安装”"></a>7、点击“从磁盘安装”</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/50335b3419e389bc1d299e8ba51f5d61.png" alt=""></p>
<h5 id="8、选择电脑上的Android-SDK目录中的android-winusb-inf-文件，android-winusb-inf-位置在-SDK目录-extras-google-usb-driver-目录中"><a href="#8、选择电脑上的Android-SDK目录中的android-winusb-inf-文件，android-winusb-inf-位置在-SDK目录-extras-google-usb-driver-目录中" class="headerlink" title="8、选择电脑上的Android SDK目录中的android_winusb.inf 文件，android_winusb.inf 位置在 %SDK目录%/extras/google/usb_driver 目录中"></a>8、选择电脑上的Android SDK目录中的android_winusb.inf 文件，android_winusb.inf 位置在 %SDK目录%/extras/google/usb_driver 目录中</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/54b265d58c3019dafb74039d1d712d34.png" alt=""></p>
<h5 id="9、点击下一步"><a href="#9、点击下一步" class="headerlink" title="9、点击下一步"></a>9、点击下一步</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/fbfc675baf29a74ef70a832d0c05689d.png" alt=""></p>
<h5 id="10、会有以下警告点击“是”"><a href="#10、会有以下警告点击“是”" class="headerlink" title="10、会有以下警告点击“是”"></a>10、会有以下警告点击“是”</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/f179372a487f149ae33bd52a5508a03e.png" alt=""></p>
<h5 id="11、经过一会后提示已安装成功"><a href="#11、经过一会后提示已安装成功" class="headerlink" title="11、经过一会后提示已安装成功"></a>11、经过一会后提示已安装成功</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/6f1a0749de71a409f198af6ef77249a5.png" alt=""></p>
<h5 id="12、之后就可以在AndroidStudio中看见可运行的设备了"><a href="#12、之后就可以在AndroidStudio中看见可运行的设备了" class="headerlink" title="12、之后就可以在AndroidStudio中看见可运行的设备了"></a>12、之后就可以在AndroidStudio中看见可运行的设备了</h5><p><img src="http://fp1.fghrsh.net/2020/01/15/ca72d77fca2ac1b444bad1064055eb11.png" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Hexo博客标签、分类不展示问题</title>
    <url>/2019/12/24/%E5%85%B3%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E6%A0%87%E7%AD%BE%E3%80%81%E5%88%86%E7%B1%BB%E4%B8%8D%E5%B1%95%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-修改主题配置文件"><a href="#1-修改主题配置文件" class="headerlink" title="1 修改主题配置文件"></a>1 修改主题配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vultr hexoDir]# vim themes/next/_config.yml</span><br></pre></td></tr></table></figure>

<h5 id="搜索menu可找到"><a href="#搜索menu可找到" class="headerlink" title="搜索menu可找到"></a>搜索menu可找到</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="comment">#主页</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#关于</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#标签</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="comment">#分类</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="comment">#归档</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#日程表</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#站点地图</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#公益404</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>可以看到，大部分都是注释，这里我已经把我需要的页面注释解除了，大家可自行考虑需要的页面。</p>
<p>在这里，<strong>斜线//</strong>之间的文字是 该页面 的名字，如／about／ ，说明我们要<strong>跳转的页面</strong>的名字为about , 而<strong>||</strong>后的文字是这个页面的图标名字.</p>
<h4 id="2-添加分类模块"><a href="#2-添加分类模块" class="headerlink" title="2 添加分类模块"></a>2 添加分类模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vultr hexoDir]# hexo new page categories</span><br></pre></td></tr></table></figure>

<ul>
<li><p>你会发现你的<code>source</code>文件夹下有了<code>categories\index.md</code>，打开<code>index.md</code>文件将 title 设置为<code>title: 分类</code> </p>
</li>
<li><p>把文章归入分类只需在文章的顶部标题下方添加<code>categories</code>字段，即可自动创建分类名并加入对应的分类中</p>
</li>
</ul>
<h4 id="3-添加标签模块"><a href="#3-添加标签模块" class="headerlink" title="3 添加标签模块"></a>3 添加标签模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vultr hexoDir]# hexo new page tags</span><br></pre></td></tr></table></figure>

<ul>
<li><p>你会发现你的<code>source</code>文件夹下有了<code>tags\index.md</code>，打开<code>index.md</code>文件将 title 设置为<code>title: 标签</code></p>
</li>
<li><p>把文章添加标签只需在文章的顶部标题下方添加<code>tags</code>字段，即可自动创建标签名并归入对应的标签中</p>
</li>
</ul>
<h4 id="4-添加归档模块"><a href="#4-添加归档模块" class="headerlink" title="4 添加归档模块"></a>4 添加归档模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vultr hexoDir]# hexo new page archives</span><br></pre></td></tr></table></figure>

<ul>
<li><p>你会发现你的<code>source</code>文件夹下有了<code>archives\index.md</code>，打开<code>index.md</code>文件将 title 设置为<code>title: 归档</code></p>
</li>
<li><p>新增文章后会自动按照文档日期生成归档内容</p>
</li>
</ul>
<h4 id="5-修改index-md文件"><a href="#5-修改index-md文件" class="headerlink" title="5 修改index.md文件"></a>5 修改index.md文件</h4><p><strong>生成文章后发现没有自动生成分类、标签和归档内容</strong></p>
<p>打开 <code>categories</code> 文件夹下的 <code>index.md</code> ，在最下面一行加一行type文字就行，注意中间有空格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="number">-12</span><span class="number">-24</span> <span class="number">11</span><span class="string">:46:57</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">categories</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>打开 <code>tags文件夹下的</code>index.md` ，在最下面一行加一行type文字就行，注意中间有空格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="number">-12</span><span class="number">-24</span> <span class="number">11</span><span class="string">:46:53</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>打开 <code>archives文件夹下的</code>index.md` ，在最下面一行加一行type文字就行，注意中间有空格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">归档</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="number">-12</span><span class="number">-24</span> <span class="number">13</span><span class="string">:52:22</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">archives</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h4 id="6-重新发布"><a href="#6-重新发布" class="headerlink" title="6 重新发布"></a>6 重新发布</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vultr hexoDir]# hexo clean</span><br><span class="line">[root@vultr hexoDir]# hexo g</span><br><span class="line">[root@vultr hexoDir]# hexo d</span><br></pre></td></tr></table></figure>

<h4 id="7-效果展示"><a href="#7-效果展示" class="headerlink" title="7 效果展示"></a>7 效果展示</h4><p><img src="http://fp1.fghrsh.net/2019/12/24/fd3bff8bd26e6519cd185b9873ca3a09.png" alt=""></p>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描二维码后立即通知实现</title>
    <url>/2020/05/16/%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%90%8E%E7%AB%8B%E5%8D%B3%E9%80%9A%E7%9F%A5%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在做微信的扫描支付的时候，遇到一个问题：如何在用户扫码支付完成之后，客户端立即得到通知，进行下一步的跳转？</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>首先想到的策略是客户端轮循查询订单的状态，根据返回的结果进行跳转</p>
<p>这个方案有明显的缺点，轮循时间设置短，频繁发送请求，对服务器以及数据库都会产生压力；轮循时间过长，用户等待时间长，体验很差；</p>
<a id="more"></a>

<p>针对这个问题想到了微信网页版的扫码登录（扫描完成后，立即登录），现研究一下它的原理并实现相同的功能</p>
<h5 id="微信扫描登录原理"><a href="#微信扫描登录原理" class="headerlink" title="微信扫描登录原理"></a>微信扫描登录原理</h5><p><img src="http://fp1.fghrsh.net/2020/05/16/89f9b5a775febad24c6c27b14d25bbe6.png" alt=""></p>
<p>可以看到图片中，前端二维码页面发送一个网络请求，但是这个请求并没有立即返回</p>
<p><img src="http://fp1.fghrsh.net/2020/05/16/ad4e93640e2d98c6f4eaf5dac97c7d52.png" alt=""></p>
<p>一段时间没有扫描后，后端返回408，前端重新发起一个相同的网络请求，并继续挂起 ( pending ) </p>
<p>据此猜测大概实现原理如下：</p>
<ol>
<li>进入网站后生成一个 ( 比如<code>UUID</code> ) </li>
<li>跳转到二维码页面 ( 二维码中的链接包含此<code>UUID</code> )</li>
<li>二维码页面向服务器发起请求，查询二维码是否被扫登录</li>
<li>服务器收到请求后查询，如果未扫登录，进入等待( <code>wait</code> )，不立即返回</li>
<li>一旦被扫，立即返回 ( <code>notify</code> )</li>
<li>页面收到结果，做后续处理</li>
</ol>
<h5 id="UUID-缓存"><a href="#UUID-缓存" class="headerlink" title="UUID 缓存"></a><code>UUID</code> 缓存</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, ScanPool&gt; cacheMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ScanPool&gt;();</span><br></pre></td></tr></table></figure>

<p>一定要使用 <code>ConcurrentHashMap</code> 否则多线程操作会报错 <code>ConcurrentModificationException</code></p>
<p>单线程中出现该异常的原因是，对一个集合遍历的同时，又对该集合进行了增删的操作</p>
<p>多线程中更易出现该异常，当你在一个线程中对一数据集合进行遍历，正赶上另外一个线程对该数据集合进行增删操作时便会出现该异常</p>
<p>缓存还要设置自动清理功能，防止增长过大</p>
<h5 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/qrcode/&#123;uuid&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createQRCode</span><span class="params">(@PathVariable String uuid, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    String text = <span class="string">"http://222.186.174.121:41408/login/"</span> + uuid;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">300</span>;</span><br><span class="line">    String format = <span class="string">"png"</span>;</span><br><span class="line">    <span class="comment">//将UUID放入缓存</span></span><br><span class="line">    ScanPool pool = <span class="keyword">new</span> ScanPool();</span><br><span class="line">    PoolCache.cacheMap.put(uuid, pool);</span><br><span class="line">    System.out.println(<span class="string">"UUID放入缓存 成功"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;EncodeHintType, Object&gt; hints = <span class="keyword">new</span> HashMap&lt;EncodeHintType, Object&gt;();</span><br><span class="line">        hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//hints.put(EncodeHintType.MARGIN, 1);</span></span><br><span class="line">        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); <span class="comment">//容错率</span></span><br><span class="line">        BitMatrix bitMatrix = <span class="keyword">new</span> MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints);</span><br><span class="line">        MatrixToImageWriter.writeToStream(bitMatrix, format, response.getOutputStream());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WriterException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"根据UUID生成二维码 成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成二维码，并将 <code>UUID</code>放入缓存中</p>
<p>此处需要注意，二维码 <code>url</code> 必须是外网可以访问地址，此处可以使用<a href="https://www.natfrp.org/" target="_blank" rel="noopener">内网穿透工具</a></p>
<h5 id="验证是否登录"><a href="#验证是否登录" class="headerlink" title="验证是否登录"></a>验证是否登录</h5><p>前端发起请求，验证该二维码是否已被扫登录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/pool"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function">String <span class="title">pool</span><span class="params">(String uuid)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"检测["</span> + uuid + <span class="string">"]是否登录"</span>);</span><br><span class="line"></span><br><span class="line">    ScanPool pool = PoolCache.cacheMap.get(uuid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"timeout"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用计时器，固定时间后不再等待扫描结果--防止页面访问超时</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> ScanCounter(pool)).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> scanFlag = pool.getScanStatus();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scanFlag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 获得状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">getScanStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isScan()) &#123; <span class="comment">//如果还未扫描，则等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isScan()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新开线程防止页面访问超时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScanCounter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long timeout = <span class="number">27000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入的对象</span></span><br><span class="line">    <span class="keyword">private</span> ScanPool scanPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScanCounter</span><span class="params">(ScanPool scanPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scanPool = scanPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(timeout);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyPool(scanPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyPool</span><span class="params">(ScanPool scanPool)</span> </span>&#123;</span><br><span class="line">        scanPool.notifyPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://fp1.fghrsh.net/2020/05/16/4887896a032a17e7bc71aad41057b2f7.png" alt=""></p>
<h5 id="扫码"><a href="#扫码" class="headerlink" title="扫码"></a>扫码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login/&#123;uuid&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function">String <span class="title">login</span><span class="params">(@PathVariable String uuid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ScanPool pool = PoolCache.cacheMap.get(uuid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"timeout,scan fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool.scanSuccess();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"扫码完成，登录成功"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"扫码完成，登录成功"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扫码成功，设置扫码状态，唤起线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scanSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setScan(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://fp1.fghrsh.net/2020/05/16/caf7b49e3a4f9ca0d1a0dbbaf2b22d8f.png" alt=""></p>
<p>手机扫码后</p>
<p><img src="http://fp1.fghrsh.net/2020/05/16/121ba31644b488ebd9b05e49427eee03.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows和Linux进行AES结果不同</title>
    <url>/2020/05/16/Windows%E5%92%8CLinux%E8%BF%9B%E8%A1%8CAES%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>项目使用到了AES加解密，本地Windows环境测试没有问题，放到生产Linux(Centos7)环境后加解密结果不一致导致程序错误的问题</p>
<a id="more"></a>

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>经过检查之后，发现有一点比较奇怪的是linux下每次加密同一字符串出来的结果都不同，于是就怀疑应该是加密的Key这里出了问题，导致每次的加密结果不同，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成加密秘钥</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKeySpec <span class="title">getSecretKey</span><span class="params">(<span class="keyword">final</span> String password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//返回生成指定算法密钥生成器的 KeyGenerator 对象</span></span><br><span class="line">    KeyGenerator kg = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        kg = KeyGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">//AES 要求密钥长度为 128</span></span><br><span class="line">        kg.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(password.getBytes()));</span><br><span class="line">        <span class="comment">//生成一个密钥</span></span><br><span class="line">        SecretKey secretKey = kg.generateKey();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), KEY_ALGORITHM);<span class="comment">// 转换为AES专用密钥</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchAlgorithmException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Logger.getLogger(AesEncryptUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()).<span class="title">log</span>(<span class="title">Level</span>.<span class="title">SEVERE</span>, <span class="title">null</span>, <span class="title">ex</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改为如下方式即可解决问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成加密秘钥</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKeySpec <span class="title">getSecretKey</span><span class="params">(<span class="keyword">final</span> String password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//返回生成指定算法密钥生成器的 KeyGenerator 对象</span></span><br><span class="line">    KeyGenerator kg = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        kg = KeyGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">        SecureRandom secureRandom = SecureRandom.getInstance(<span class="string">"SHA1PRNG"</span>);</span><br><span class="line">        secureRandom.setSeed(password.getBytes());</span><br><span class="line">        <span class="comment">//AES 要求密钥长度为 128</span></span><br><span class="line">        kg.init(<span class="number">128</span>, secureRandom);</span><br><span class="line">        <span class="comment">//生成一个密钥</span></span><br><span class="line">        SecretKey secretKey = kg.generateKey();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), KEY_ALGORITHM);<span class="comment">// 转换为AES专用密钥</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchAlgorithmException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Logger.getLogger(AesEncryptUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()).<span class="title">log</span>(<span class="title">Level</span>.<span class="title">SEVERE</span>, <span class="title">null</span>, <span class="title">ex</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>查询资料后发现是：<code>kg.init(128, new SecureRandom(password.getBytes()));</code>  这一段代码有问题。</p>
<p> <code>SecureRandom</code> 实现完全随操作系统本身的内部状态，除非调用方在调用 <code>getInstance</code> 方法之后又调用了 <code>setSeed</code> 方法；改实现在Windows上每次生成的Key都相同，但是在 <code>Solaris</code> 或部分 <code>Linux</code>系统上则不同；</p>
<hr>
<h4 id="最后附上AesEncryptUtils工具类"><a href="#最后附上AesEncryptUtils工具类" class="headerlink" title="最后附上AesEncryptUtils工具类"></a>最后附上AesEncryptUtils工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AesEncryptUtils</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"AES"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CIPHER_ALGORITHM = <span class="string">"AES/ECB/PKCS5Padding"</span>;<span class="comment">//默认的加密算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES 加密操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content  待加密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 加密密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回Base64转码后的加密数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String content, String password)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);<span class="comment">// 创建密码器</span></span><br><span class="line">            <span class="keyword">byte</span>[] byteContent = content.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(password));<span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">            <span class="keyword">byte</span>[] result = cipher.doFinal(byteContent);<span class="comment">// 加密</span></span><br><span class="line">            <span class="keyword">return</span> Base64.encodeBase64String(result);<span class="comment">//通过Base64转码返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Logger.getLogger(AesEncryptUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()).<span class="title">log</span>(<span class="title">Level</span>.<span class="title">SEVERE</span>, <span class="title">null</span>, <span class="title">ex</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES 解密操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String content, String password)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//实例化</span></span><br><span class="line">            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);</span><br><span class="line">            <span class="comment">//使用密钥初始化，设置为解密模式</span></span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, getSecretKey(password));</span><br><span class="line">            <span class="comment">//执行操作</span></span><br><span class="line">            <span class="keyword">byte</span>[] result = cipher.doFinal(Base64.decodeBase64(content));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(result, StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Logger.getLogger(AesEncryptUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()).<span class="title">log</span>(<span class="title">Level</span>.<span class="title">SEVERE</span>, <span class="title">null</span>, <span class="title">ex</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密秘钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKeySpec <span class="title">getSecretKey</span><span class="params">(<span class="keyword">final</span> String password)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//返回生成指定算法密钥生成器的 KeyGenerator 对象</span></span><br><span class="line">        KeyGenerator kg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            kg = KeyGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">            SecureRandom secureRandom = SecureRandom.getInstance(<span class="string">"SHA1PRNG"</span>);</span><br><span class="line">            secureRandom.setSeed(password.getBytes());</span><br><span class="line">            <span class="comment">//AES 要求密钥长度为 128</span></span><br><span class="line">            kg.init(<span class="number">128</span>, secureRandom);</span><br><span class="line">            <span class="comment">//生成一个密钥</span></span><br><span class="line">            SecretKey secretKey = kg.generateKey();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), KEY_ALGORITHM);<span class="comment">// 转换为AES专用密钥</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchAlgorithmException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Logger.getLogger(AesEncryptUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()).<span class="title">log</span>(<span class="title">Level</span>.<span class="title">SEVERE</span>, <span class="title">null</span>, <span class="title">ex</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">"20191127120752-833"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line"></span><br><span class="line">        String s1 = AesEncryptUtils.encrypt(s, <span class="string">"b8e7f17e785f450e"</span>);</span><br><span class="line">        System.out.println(<span class="string">"s1:"</span> + s1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s2:"</span> + AesEncryptUtils.decrypt(s1, <span class="string">"b8e7f17e785f450e"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AES加解密</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker操作指北</title>
    <url>/2020/06/13/Docker%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<h2 id="Docker-操作指北"><a href="#Docker-操作指北" class="headerlink" title="Docker 操作指北"></a>Docker 操作指北</h2><h4 id="一）常用命令"><a href="#一）常用命令" class="headerlink" title="一）常用命令"></a>一）常用命令</h4><hr>
<h5 id="拉取-Docker-镜像"><a href="#拉取-Docker-镜像" class="headerlink" title="拉取 Docker 镜像"></a>拉取 <code>Docker</code> 镜像</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull image_name</span><br></pre></td></tr></table></figure>

<p>我们通过最简单的 <code>image</code> 文件 “hello world”，感受一下 <code>Docker</code>。</p>
<p>因为国内连接 <code>Docker</code> 的官方仓库很慢，因此我们在日常使用中会使用 <code>Docker</code> 中国加速器。通过 <code>Docker</code> 官方镜像加速，中国区用户能够快速访问最流行的 <code>Docker</code> 镜像。该镜像托管于中国大陆，我们配置国内镜像可以享受到更快的下载速度和更强的稳定性，从而能够更敏捷的开发和交付 <code>Docker</code> 化应用。</p>
<p><code>Docker</code> 中国官方镜像加速可通过 <code>registry.docker-cn.com</code> 访问。该镜像只包含流行的公有镜像，私有镜像仍需要从美国镜像中拉去。</p>
<p>修改系统中 <code>Docker</code> 对应的配置文件即可，如下包含了公司仓库和一些其他国内镜像：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"debug"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"experimental"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"registry.becypress.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://mirror.ccs.tencentyun.com"</span>,</span><br><span class="line">    <span class="string">"https://hub-mirror.c.163.com"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span>,</span><br><span class="line">    <span class="string">"http://f1361db2.m.daocloud.io"</span>,</span><br><span class="line">    <span class="string">"https://docker.mirrors.ustc.edu.cn"</span>,</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="win10配置方式："><a href="#win10配置方式：" class="headerlink" title="win10配置方式："></a>win10配置方式：</h6><p>右键电脑右下角的Docker 图标–&gt;Settings–&gt;Docker Engine—&gt; 将加速器地址复制到该页面上的文本框中，点击Apply 然后等待Docker重启，重启完毕就可以使用新的Docker镜像源了！！！</p>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613114536.png" alt=""></p>
<h6 id="其他-windows-配置方式："><a href="#其他-windows-配置方式：" class="headerlink" title="其他 windows 配置方式："></a>其他 windows 配置方式：</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 进入 Docker 虚拟机</span><br><span class="line">docker-machine.exe ssh default</span><br><span class="line"># 编辑 Docker 配置文件</span><br><span class="line">sudo vi /etc/docker/daemon.json</span><br><span class="line"># 按下 i 进入编辑模式添加以上配置</span><br><span class="line"># 按下 : 退出编辑模式</span><br><span class="line"># 按下 wq 保存并退出</span><br><span class="line"># 退出虚拟机按下 exit</span><br></pre></td></tr></table></figure>

<p><img src="http://image.berlin4h.top/images/2020/06/13/image-20200613120012624.png" alt=""></p>
<p><img src="http://image.berlin4h.top/images/2020/06/13/image-20200613120048944.png" alt=""></p>
<h6 id="linux-系统配置方式："><a href="#linux-系统配置方式：" class="headerlink" title="linux 系统配置方式："></a>linux 系统配置方式：</h6><p><img src="http://image.berlin4h.top/images/2020/06/13/image-20200613120048944.png" alt=""></p>
<p>配置好后运行如下命令，将 image (镜像) 文件从仓库抓去到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>docker image pull</code> 是抓取 <code>image</code> 文件的命令。<code>library/hello-world</code> 是 <code>image</code> 文件在仓库里面的位置，其中 <code>library</code> 是 <code>image</code> 文件所在的组，<code>hello-world</code> 是 <code>image</code> 文件的名字。</p>
<h5 id="查看宿主机上的镜像，Docker-镜像保存在-var-lib-docker-目录下"><a href="#查看宿主机上的镜像，Docker-镜像保存在-var-lib-docker-目录下" class="headerlink" title="查看宿主机上的镜像，Docker 镜像保存在 /var/lib/docker 目录下"></a>查看宿主机上的镜像，<code>Docker</code> 镜像保存在 <code>/var/lib/docker</code> 目录下</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>

<p><code>OPTIONS</code> 说明：</p>
<ul>
<li>-a：列出本地所有的镜像（含中间映像蹭，默认情况下，过滤调中间映像层）；</li>
<li>–digests：显示镜像的摘要信息；</li>
<li>-f：显示满足条件的镜像；</li>
<li>–format：指定返回值的模版文件；</li>
<li>–no-trunc：显示完整的镜像信息；</li>
<li>-q：只显示镜像ID；</li>
</ul>
<p><code>hello-world</code> 镜像抓取成功后，就可以在本机看到这个 <code>image</code> 文件了。</p>
<p><img src="http://image.berlin4h.top/images/2020/06/13/image-20200613121311719.png" alt=""></p>
<h5 id="运行镜像：会创建一个新的容器并运行"><a href="#运行镜像：会创建一个新的容器并运行" class="headerlink" title="运行镜像：会创建一个新的容器并运行"></a>运行镜像：会创建一个新的容器并运行</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] image_name/image_id [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>

<p><code>OPTIONS</code> 说明：</p>
<ul>
<li>-a stdin：指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li>
<li>-d：后台运行容器，并返回容器ID；</li>
<li>-i：以交互模式运行容器，通常与 -t 同时使用；</li>
<li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li>
<li>-P：随机端口映射，容器内部端口随机映射到主机的高端口；</li>
<li>-p：指定端口映射，格式为：<strong>主机（宿主）端口：容器端口</strong>；</li>
<li>–name：为容器指定一个名称；</li>
<li>–dns：指定容器使用的DNS服务器，默认和宿主一致；</li>
<li>–dns-search：指定容器DNS搜索域名，默认和宿主一致；</li>
<li>-h：指定容器的 <code>hostname</code>；</li>
<li>-e：设置环境变量；</li>
<li>–env-file：从指定文件读入环境变量；</li>
<li>–cpuset：绑定容器到指定CPU运行；</li>
<li>-m：设置容器使用内存最大值；</li>
<li>–network：指定容器网络模式；</li>
<li>–ip：指定容器IP；</li>
<li>–network-alias：指定容器网络别名；</li>
<li>…：其他可通过 docker run –help 查看</li>
</ul>
<p>现在运行 <code>hello-world</code> 这个镜像文件：</p>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613145919.png" alt=""></p>
<p>输出这段提示以后，<code>hello-world</code> 就会停止，容器自动终止。有些容器不会自动终止，因为提供的是服务，比如 <code>Oracle</code>、<code>Mysql</code>镜像等。</p>
<h5 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<p><code>OPTIONS</code> 说明：</p>
<ul>
<li>-a：显示所有的容器，包括未运行的；</li>
<li>-f：根据条件过滤显示的内容；</li>
<li>–format：指定返回值的模版文件；</li>
<li>-l：显示最近创建的容器；</li>
<li>-n：列出最近创建的n个容器；</li>
<li>–no-trunc：不截断输出；</li>
<li>-q：只显示容器ID；</li>
<li>-s：显示总的文件大小；</li>
</ul>
<p>查看之前启动的 <code>hello-world</code> 容器：</p>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613150720.png" alt=""></p>
<p>输出详情介绍：</p>
<ul>
<li><p>CONTAINER ID：容器ID；</p>
</li>
<li><p>IMAGE：使用的镜像；</p>
</li>
<li><p>COMMAND：启动容器运行时的命令；</p>
</li>
<li><p>CREATED：容器的创建时间；</p>
</li>
<li><p>STATUS：容器状态</p>
<ul>
<li>created：已创建</li>
<li>restarting：重启中</li>
<li>running：运行中</li>
<li>removing：迁移中</li>
<li>paused：暂停</li>
<li>exited：停止</li>
<li>dead：死亡</li>
</ul>
</li>
<li><p>PORTS：容器的端口信息和使用的连接类型（tcp/udp）</p>
</li>
<li><p>NAMES：自动分配的容器名称；</p>
</li>
</ul>
<h5 id="启动、停止、重启容器"><a href="#启动、停止、重启容器" class="headerlink" title="启动、停止、重启容器"></a>启动、停止、重启容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start container_name/container_id</span><br><span class="line">docker stop container_name/container_id</span><br><span class="line">docker restart containcer_name/container_id</span><br></pre></td></tr></table></figure>

<p>我们现在可以将 <code>hello-world</code> 容器启动：</p>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613151802.png" alt=""></p>
<h5 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec [OPTIONS] container_name/container_id COMMAND [ARG...]</span><br></pre></td></tr></table></figure>

<p><code>OPRIONS</code> 说明：</p>
<ul>
<li>-d：分离模式，在后台运行</li>
<li>-i：即使没有附加也保持STDIN打开</li>
<li>-t：分配一个伪终端</li>
</ul>
<p>通过 <code>exec</code> 命令对指定的容器执行 sh：</p>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613152853.png" alt=""></p>
<p>通过 <code>exec</code> 命令对指定的容器执行 bash：</p>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613153034.png" alt=""></p>
<h5 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker logs [<span class="type">OPTIONS</span>] container_name/container_id</span><br></pre></td></tr></table></figure>

<p><code>OPTIONS</code> 说明：</p>
<ul>
<li>-f：跟踪日志输出；</li>
<li>–since：显示某个开始时间的所有日志</li>
<li>-t：显示时间戳</li>
<li>–tail：仅列出最新的N条容器日志</li>
</ul>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613153822.png" alt=""></p>
<h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm [OPTIONS] container_name/container_id</span><br></pre></td></tr></table></figure>

<p><code>OPTIONS</code> 说明：</p>
<ul>
<li>-f：通过 SIGKILL 信号强制删除一个运行中容器；</li>
<li>-l：移除容器间的网络连接，而非容器本身；</li>
<li>-v：删除与容器相关的卷；</li>
</ul>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613154105.png" alt=""></p>
<h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi [OPTIONS] image_name/image_id</span><br></pre></td></tr></table></figure>

<p><code>OPTIONS</code> 说明：</p>
<ul>
<li>-f：强制删除；</li>
<li>–no-prune：不移除该镜像的过程镜像，默认移除；</li>
</ul>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613154642.png" alt=""></p>
<h5 id="查看当前系统-Docker-信息"><a href="#查看当前系统-Docker-信息" class="headerlink" title="查看当前系统 Docker 信息"></a>查看当前系统 <code>Docker</code> 信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613154937.png" alt=""></p>
<h4 id="二）Dockerfile"><a href="#二）Dockerfile" class="headerlink" title="二）Dockerfile"></a>二）<code>Dockerfile</code></h4><hr>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><code>Docker</code> 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，这个脚本就是 <code>Dockerfile</code>。</p>
<p><code>Dockerfile</code> 是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 <code>Dockerfile</code>，当我们需要定制自己额外的需求时，只需要在 <code>Dockerfile</code> 上添加或者修改指令，重新生成 <code>image</code> 即可，省去了敲命令的麻烦。</p>
<p>简单来说：<code>Dockerfile</code> 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h5 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h5><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、第一行必须指定 基础镜像信息</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"><span class="comment"># 2、维护者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> docker_user docker_user@email.com</span><br><span class="line"><span class="comment"># 3、镜像操作指令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'这是一个本地构建的nginx镜像'</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="comment"># 4、容器启动执行指令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/sbin/nginx</span></span><br></pre></td></tr></table></figure>

<p><code>Dockerfile</code> 分为四部分：<strong>基础镜像信息、维护者信息、镜像操作指令、容器启动执行指令</strong>。一开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如 <code>RUN</code> 指令。每执行一条 <code>RUN</code> 指令，镜像添加新的一层，并提交；最后是 <code>CMD</code> 指令，来指明运行容器时的操作命令。</p>
<p><strong>注意</strong>：<code>Dockerfile</code> 的指令每执行一次都会在 <code>docker</code> 上新建一层。所以过多无意义的层会造成镜像膨胀过大；</p>
<h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><p>在 <code>Dockerfile</code> 文件的存放目录下，执行构建动作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>

<p><code>OPTIONS</code> 说明：</p>
<ul>
<li>-t / -tag：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签；</li>
<li>–build-arg：设置镜像创建时的变量；</li>
<li>–cpu-shares：设置 cpu 使用权重；</li>
<li>-f：指定要使用的 <code>Dockerfile</code> 路径；</li>
<li>-m：设置内存最大值；</li>
<li>…其他可通过 docker build –help 查看</li>
</ul>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613165948.png" alt=""></p>
<p><strong>注</strong>：<code>docker build -t nginx:test .</code> 代表本次执行的上下文路径（上下文路径是指 <code>docker</code> 在构建镜像，有时候需要使用本机的文件，比如复制，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包）。</p>
<h5 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure>

<p><code>OPTIONS</code>：说明</p>
<ul>
<li>–disable-content-trust：忽略镜像的校验，默认开启</li>
</ul>
<p><img src="http://image.berlin4h.top/images/2020/06/13/20200613173142.png" alt=""></p>
<h5 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h5><ul>
<li><p>FROM：定制的镜像都是基于 <code>FROM</code> 的镜像，这里的 <code>nginx</code> 就是定制需要的基础镜像。后续操作都是基于nginx；</p>
<ul>
<li>格式：<code>FROM &lt;image&gt;[:&lt;TAG&gt;]</code></li>
</ul>
</li>
<li><p>RUN：用于执行后面跟着的命令，等同于在终端操作的 shell 命令；</p>
<ul>
<li>格式：<code>RUN &lt;command&gt;</code></li>
</ul>
</li>
<li><p>CMD：类似与 <code>RUN</code> 指令，用于运行程序，但两者运行的时间不同</p>
<ul>
<li><code>CMD</code> 是在 <code>docker run</code> 时运行，如果多个 <code>CMD</code> 指令仅最后一个生效</li>
<li><code>RUN</code> 是在 <code>docker build</code> 时运行</li>
</ul>
</li>
<li><p>COPY：复制指令，从上下文目录中复制文件或者目录到指定容器里的指定路径</p>
<ul>
<li>格式：<code>COPY</code> 源路径/文件 目标路径/文件</li>
<li>案例：<code>COPY ./target/service-caterer-2.0.0.war app.war</code></li>
</ul>
</li>
<li><p>ADD：添加指令，和 <code>COPY</code> 指令使用格式一致；</p>
</li>
<li><p>ENV：设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量；</p>
<ul>
<li><p>格式：<code>ENV &lt;key&gt; &lt;value&gt;</code> 或者 <code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;</code></p>
</li>
<li><p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz"</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>ARG：构建参数，与 <code>ENV</code> 作业一致。不过作用域不一样，<code>ARG</code> 设置的环境变量仅对 <code>Dockerfile</code> 内有效，也就是说只有 <code>docker build</code> 的过程有效，构建好的镜像内不存在此环境变量。</p>
<ul>
<li>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li>
</ul>
</li>
<li><p>VOLUME：定义匿名数据卷，在启动容器的时候忘记挂载数据卷，会自动挂载到匿名卷。</p>
<ul>
<li>格式：<code>VOLUME [&quot;&lt;路径1&gt;&quot;,&quot;&lt;路径2&gt;&quot;...]</code> </li>
<li>作用：避免重要的数据，因容器重启而丢失，这是非常致命的</li>
</ul>
</li>
<li><p>EXPOSE：为构建的镜像设置监听端口，使容器在运行时监听。</p>
<ul>
<li>格式：<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></li>
<li>作用：帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；且镜像在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</li>
</ul>
</li>
<li><p>WORKDIR：指定工作目录。用 <code>WORKDIR</code> 指定的工作目录，会在构建镜像的每一层中都存在（<code>WORKDIR</code> 指定的工作目录，必须时提前创建好的）。</p>
<ul>
<li>格式： <code>WORKDIR &lt;工作目录路径&gt;</code></li>
</ul>
</li>
<li><p>USER：用于指定后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<ul>
<li>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></li>
</ul>
</li>
</ul>
<h4 id="三）Docker-Compose"><a href="#三）Docker-Compose" class="headerlink" title="三）Docker Compose"></a>三）Docker Compose</h4><p>待完善。。。</p>
]]></content>
  </entry>
  <entry>
    <title>Windows安装MySQL8.0.18教程</title>
    <url>/2020/01/05/Windows%E5%AE%89%E8%A3%85MySQL8.0.18%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1 下载安装包"></a>1 下载安装包</h4><p>去官网<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载MySQL</a></p>
<p><img src="http://fp1.fghrsh.net/2020/01/05/477045ef191c661af6018429596c67a7.png" alt=""></p>
<a id="more"></a>

<h4 id="2-将下载好的压缩文件解压"><a href="#2-将下载好的压缩文件解压" class="headerlink" title="2 将下载好的压缩文件解压"></a>2 将下载好的压缩文件解压</h4><p>解压缩下载之后的zip，这里我使用的安装路径为：</p>
<p><code>F:\MySQL\mysql-8.0.18-winx64</code></p>
<p>解压缩之后，需要在安装路径的根目录下创建 <code>data</code>件夹和 <code>my.ini</code> 文件</p>
<p><code>data文件夹</code>：用于存储<code>mysql</code>的数据库文件</p>
<p><code>my.ini</code>：这是<code>mysql</code>的配置文件</p>
<p><img src="http://fp1.fghrsh.net/2020/01/05/9b72be49d3775f779e6bbdd9173496ae.png" alt=""></p>
<h4 id="3-配置my-ini文件"><a href="#3-配置my-ini文件" class="headerlink" title="3 配置my.ini文件"></a>3 配置my.ini文件</h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=F:\MySQL\mysql-<span class="number">8.0</span>.<span class="number">18</span>-winx64</span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=F:\MySQL\mysql-<span class="number">8.0</span>.<span class="number">18</span>-winx64\data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line"><span class="attr">max_connect_errors</span>=<span class="number">10</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为UTF8</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br></pre></td></tr></table></figure>

<p><strong>注意：<code>my.ini</code>文件的格式要是<code>ANSI</code>格式，否则会导致<code>mysql</code>无法安装/启动</strong></p>
<h4 id="4-初始化并启动MySQL服务"><a href="#4-初始化并启动MySQL服务" class="headerlink" title="4 初始化并启动MySQL服务"></a>4 初始化并启动MySQL服务</h4><p>安装时，为避免出错我们尽量使用管理员身份运行CMD命令行，否则则安装时会报错导致安装失败</p>
<p>进入<code>MySQL</code>的安装目录</p>
<p><img src="http://fp1.fghrsh.net/2020/01/05/9d2f64ddc1e3df32b0a04d88e688b043.png" alt=""></p>
<p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--初始化，会打印数据库密码，记住该密码，后面会用到</span><br><span class="line">mysqld --initialize --console</span><br><span class="line"> </span><br><span class="line">--安装mysql并指定服务名称</span><br><span class="line">mysqld --install localmysql</span><br><span class="line">  </span><br><span class="line">--这里是启动服务名字，就是刚刚命名的名字</span><br><span class="line">net start localmysql</span><br><span class="line">  </span><br><span class="line">--登陆数据库，这时会让你输入密码初始化时打印出的密码</span><br><span class="line">mysql -u root -p</span><br><span class="line">  </span><br><span class="line">--密码过于难记，修改密码为：123456</span><br><span class="line">set password for root@localhost='root';</span><br></pre></td></tr></table></figure>

<p>初始化<code>MySQL</code>时打印的密码</p>
<p><img src="http://fp1.fghrsh.net/2020/01/05/ec5229e30b5cd2888f21ccafe7793254.png" alt=""></p>
<h4 id="5-安装验证"><a href="#5-安装验证" class="headerlink" title="5 安装验证"></a>5 安装验证</h4><p>按 <code>win+r</code>打开运行输入<code>services.msc</code>进入服务，如果看到<code>localmysql</code>说明服务安装成功</p>
<p><img src="http://fp1.fghrsh.net/2020/01/05/3dbdf519ccfe0cde861eb9af987c3a85.png" alt=""></p>
<p>如果服务没启动可双击启动，或命令行输入<code>net start localmysql</code>来启动<code>MySQL</code></p>
<h4 id="6-使用navicat工具连接MySQL"><a href="#6-使用navicat工具连接MySQL" class="headerlink" title="6 使用navicat工具连接MySQL"></a>6 使用<code>navicat</code>工具连接MySQL</h4><p><img src="http://fp1.fghrsh.net/2020/01/05/821fdb26758dfc0c12f79e20b6864a2d.png" alt=""></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS服务器搭建Hexo+GitHub+Nginx</title>
    <url>/2019/12/24/VPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAHexo-GitHub-Nginx/</url>
    <content><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h4><p>关于个人博客，其实自己很早之前就有了这个打算，然而因为种种的原因<del>（其实就是自己懒）</del>，自己一直没有把自己的博客真正的上线。Hexo是一款基于Node.js的快速，简单而强大的博客框架。我们可以使用Markdown（或其他语言）编写文章，可以方便的生成静态网页托管在GitHub上。</p>
<p>下面是我自己搭建<a href="http://blog.berlin4h.top/" target="_blank" rel="noopener">博客</a>的基本流程不包含美化主题。</p>
<a id="more"></a>

<hr>
<h4 id="2-前期准备"><a href="#2-前期准备" class="headerlink" title="2 前期准备"></a>2 前期准备</h4><ul>
<li><p>一台VPS服务器（<strong>必须</strong>），我选用的是国际知名的vultr，速度不错、稳定且性价比高，按小时计费，能够随时开通和删除服务器，新服务器即是新ip，顺便搭了个酸酸乳效果不错。</p>
</li>
<li><p>一个域名（<strong>非必须</strong>），可以使用<a href="https://github.com" target="_blank" rel="noopener">github</a>搭建blog。他们既拥有绝对管理权，又享受github带来的便利—-不管何时何地，只要向主机提交commit，就能发布新文章。更妙的是，这一切还是免费的，github提供无限流量，世界各地都有理想的访问速度。</p>
</li>
</ul>
<hr>
<h4 id="3-开始搭建"><a href="#3-开始搭建" class="headerlink" title="3 开始搭建"></a>3 开始搭建</h4><h5 id="3-1-安装Nodejs"><a href="#3-1-安装Nodejs" class="headerlink" title="3.1 安装Nodejs"></a>3.1 安装Nodejs</h5><p>由于CentOS相当的稳定，编译环境都是非常稳定的旧版本，包括CentOS6.x的<code>Python2.6</code>在内已经满足不了新版本Node安装的需要。在使用源码安装方式之前，要更新老版本的编译环境，如果是像我这样仅仅只是使用Node的话，推荐使用二进制安装方法。</p>
<p>二进制安装比编译安装在安装步骤上简单方便了许多，省去了编译环境的更新。详细介绍可<a href="https://github.com/nodesource/distributions#rpm" target="_blank" rel="noopener">点击这里</a>查看各个版本Node在Linux系统下二进制安装官方文档。<br> CentOS安装Node11.x版本步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]# curl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_11.x | bash -</span><br><span class="line">[root@vultr ~]# yum install -y nodejs</span><br></pre></td></tr></table></figure>

<p>命令行依次输入 <code>node -v</code>、<code>npm -v</code> 查看当前安装的版本号，检查是否安装成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]# node -v</span><br><span class="line">v11.15.0</span><br><span class="line">[root@vultr ~]# npm -v</span><br><span class="line">6.13.4</span><br></pre></td></tr></table></figure>

<h5 id="3-2-安装Git（已安装可以跳过）"><a href="#3-2-安装Git（已安装可以跳过）" class="headerlink" title="3.2 安装Git（已安装可以跳过）"></a>3.2 安装Git（已安装可以跳过）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]# yum -y install git</span><br><span class="line">[root@vultr ~]# git --version</span><br><span class="line">git version 1.7.1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>进行git全局配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]# git config --global user.name "HBLc"</span><br><span class="line">[root@vultr ~]# git config --global user.email "xxx@xx.xx"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-3-安装Hexo"><a href="#3-3-安装Hexo" class="headerlink" title="3.3 安装Hexo"></a>3.3 安装Hexo</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]# cd /usr/local/</span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个博客目录给Hexo使用，Hexo要求一个空的文件夹，所以git init要等Hexo初始化之后</span></span><br><span class="line">[root@vultr local]# mkdir hexoDir</span><br><span class="line"><span class="meta">#</span><span class="bash">进入这个博客目录中去</span></span><br><span class="line">[root@vultr local]# cd hexoDir/</span><br><span class="line"><span class="meta">#</span><span class="bash">使用npm安装Hexo，安装的是Hexo的命令行工具，安装成功之后可以使用hexo命令</span></span><br><span class="line">[root@vultr hexoDir]# npm install -g hexo-cli </span><br><span class="line"><span class="meta">#</span><span class="bash">进行Hexo初始化</span></span><br><span class="line">[root@vultr hexoDir]# hexo init</span><br><span class="line"><span class="meta">#</span><span class="bash">初始化成功查看都有什么文件</span></span><br><span class="line">[root@vultr hexoDir]# ls</span><br><span class="line">_config.yml  node_modules  package.json  package-lock.json  scaffolds  source  themes</span><br><span class="line"><span class="meta">#</span><span class="bash">安装Hexo依赖</span></span><br><span class="line">[root@vultr hexoDir]# npm install</span><br><span class="line"><span class="meta">#</span><span class="bash">安装远程部署插件（此刻博客已经创建成功）</span></span><br><span class="line">[root@vultr hexoDir]# npm install hexo-deployer-git --save</span><br><span class="line"><span class="meta">#</span><span class="bash">安装本地启动插件，主要用于本地预览</span></span><br><span class="line">[root@vultr hexoDir]# npm install hexo-server --save</span><br></pre></td></tr></table></figure>

<h5 id="3-4-本地测试看看效果"><a href="#3-4-本地测试看看效果" class="headerlink" title="3.4 本地测试看看效果"></a>3.4 本地测试看看效果</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动本地服务，外部网络无法访问</span></span><br><span class="line">[root@vultr hexoDir]# hexo server</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br><span class="line"><span class="meta">#</span><span class="bash">重开一个终端，使用文本浏览器eslinks访问网址</span></span><br><span class="line"><span class="meta">#</span><span class="bash">首先安装eslinks</span></span><br><span class="line">[root@vultr ~]# yum -y install elinks</span><br><span class="line">[root@vultr ~]# elinks http://localhost:4000/</span><br></pre></td></tr></table></figure>

<h5 id="3-5-部署到GitHub上"><a href="#3-5-部署到GitHub上" class="headerlink" title="3.5 部署到GitHub上"></a>3.5 部署到GitHub上</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入博客目录</span></span><br><span class="line">[root@vultr ~]# cd /usr/local/hexoDir/</span><br><span class="line"><span class="meta">#</span><span class="bash">清除缓存，若是网页正常情况下可以忽略这条命令</span></span><br><span class="line">[root@vultr hexoDir]# hexo clean</span><br><span class="line"><span class="meta">#</span><span class="bash">hexo generate 生成静态页面</span></span><br><span class="line">[root@vultr hexoDir]# hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash">hexo delopy 部署</span></span><br><span class="line">[root@vultr hexoDir]# hexo d</span><br><span class="line"><span class="meta">#</span><span class="bash">部署成功之后将在github仓库中看到部署的文件</span></span><br></pre></td></tr></table></figure>

<h4 id="4-成果"><a href="#4-成果" class="headerlink" title="4 成果"></a>4 成果</h4><h5 id="4-1-访问github为我们提供的域名-youusername-github-oi"><a href="#4-1-访问github为我们提供的域名-youusername-github-oi" class="headerlink" title="4.1 访问github为我们提供的域名(youusername.github.oi)"></a>4.1 访问github为我们提供的域名(youusername.github.oi)</h5><p>以下展示的<a href="https://hblc.github.io/">博客</a>，笔者使用了<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">NexT</a>主题</p>
<p><img src="http://fp1.fghrsh.net/2019/12/24/26fb3a68d5c8e7588f388e9c1f4f6405.png" alt=""></p>
<h5 id="4-2-用自己的域名访问-前提需要将自己的域名解析到博客所在的服务器"><a href="#4-2-用自己的域名访问-前提需要将自己的域名解析到博客所在的服务器" class="headerlink" title="4.2 用自己的域名访问(前提需要将自己的域名解析到博客所在的服务器)"></a>4.2 用自己的域名访问(前提需要将自己的域名解析到博客所在的服务器)</h5><p><strong>这里不做演示了，注意如果你的VPS服务器没有用Nginx做反向代理，那么解析成功之后需要用你的域名+端口号4000可访问到，因为Hexo启动的端口是4000</strong></p>
<h4 id="5-使用Nginx反向代理服务器以实现不带端口的域名访问"><a href="#5-使用Nginx反向代理服务器以实现不带端口的域名访问" class="headerlink" title="5 使用Nginx反向代理服务器以实现不带端口的域名访问"></a>5 使用Nginx反向代理服务器以实现不带端口的域名访问</h4><p><strong>安装并启动Nginx</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装Nginx</span></span><br><span class="line">[root@vultr hexoDir]# yum -y install nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">查看Nginx状态(Centos6)</span></span><br><span class="line">[root@vultr hexoDir]# service nginx status</span><br><span class="line">nginx is stopped</span><br><span class="line"><span class="meta">#</span><span class="bash">启动Nginx(Centos6)</span></span><br><span class="line">[root@vultr hexoDir]# service nginx start</span><br><span class="line">Starting nginx:                                            [  OK  ]</span><br><span class="line"><span class="meta">#</span><span class="bash">设置Nginx开机自启动(Centos6)</span></span><br><span class="line">[root@vultr hexoDir]# chkconfig nginx on </span><br><span class="line"><span class="meta">#</span><span class="bash">为Hexo创建一个规则 进入Nginx配置目录</span></span><br><span class="line">[root@vultr hexoDir]# cd /etc/nginx/conf.d/</span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个新的配置文件用于Hexo博客</span></span><br><span class="line">[root@vultr conf.d]# touch hexo.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">编辑hexo.conf</span></span><br><span class="line">[root@vultr conf.d]# vim hexo.conf </span><br><span class="line"><span class="meta">#</span><span class="bash">按i进入编辑模式，填入以下ginx配置，填充成功后按Esc，再按:wq保存</span></span><br><span class="line"><span class="meta">#</span><span class="bash">成功添加hexo规则之后重启Nginx</span></span><br><span class="line">[root@vultr conf.d]# service nginx restart</span><br><span class="line">Stopping nginx:                                            [  OK  ]</span><br><span class="line">Starting nginx:                                            [  OK  ]</span><br></pre></td></tr></table></figure>

<p><strong>Nginx配置</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="comment">#这里填上你自己的博客域名,我的就是blog.berlin4h.top</span></span><br><span class="line">    <span class="attribute">server_name</span> blog.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment">#监听80端口和bolg.com域名指向博客的内容文件夹</span></span><br><span class="line">        <span class="attribute">root</span> /usr/local/hexoDir/public;</span><br><span class="line">        <span class="attribute">index</span> index.jsp index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Centos7安装Nginx</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装Nginx</span></span><br><span class="line">[root@vultr hexoDir]# yum -y install nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">查看Nginx状态</span></span><br><span class="line">[root@vultr hexoDir]# systemctl status nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">启动Nginx</span></span><br><span class="line">[root@vultr hexoDir]# systemctl start nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">设置Nginx开机自启动</span></span><br><span class="line">[root@vultr hexoDir]# systemctl enable nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">重启Nginx</span></span><br><span class="line">[root@vultr hexoDir]# systemctl restart nginx</span><br></pre></td></tr></table></figure>

<p><strong>Nginx启动成功之后可用自己的域名访问到博客</strong></p>
<p><img src="http://fp1.fghrsh.net/2019/12/24/899a76a289bfad68d519252011a9e438.png" alt=""></p>
<h4 id="6-发布文章"><a href="#6-发布文章" class="headerlink" title="6 发布文章"></a>6 发布文章</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入博客根目录下</span></span><br><span class="line">[root@vultr hexoDir]# hexo n "VPS服务器搭建Hexo+GitHub+Nginx"</span><br><span class="line"><span class="meta">#</span><span class="bash">会在博客根目录下的<span class="built_in">source</span>文件夹中的_post文件夹中多了一个文章名字.md文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">然后将写好的md文件内容复制到刚生成的md文件中,回到博客目录，部署博客</span></span><br><span class="line">[root@vultr hexoDir]# hexo clean</span><br><span class="line">[root@vultr hexoDir]# hexo g</span><br><span class="line">[root@vultr hexoDir]# hexo d</span><br></pre></td></tr></table></figure>

<p><strong>现在就可以开始个人博客之旅了</strong></p>
<p><strong>至此博客基本就搭建完毕</strong></p>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Nginx</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
